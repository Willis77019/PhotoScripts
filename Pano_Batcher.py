{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "010db421-772e-432f-8bce-6e078669c27e",
   "metadata": {},
   "source": [
    "\"\"\"\n",
    "-------------------------------------------------------------------------------\n",
    "PANORAMA BATCH STITCHER\n",
    "-------------------------------------------------------------------------------\n",
    "Batch process photomosaic construction.\n",
    "Author: Brian Willis<br>\n",
    "AI programming support: Gemini 3 pro<br>\n",
    "Contact: Willis77019@gmail.com<br>\n",
    "License:  MIT License (unrestricted: Use at your own risk)<br>\n",
    "\n",
    "DESCRIPTION:\n",
    "This script automates the stitching of multiple panoramic mosaics from a single\n",
    "folder of images. It will stitch photomosaics constructed from a single row of photos or multiple rows of photos. It supports .JPG and Nikon RAW (.NEF) files (extendable to others).\n",
    "\n",
    "PREREQUISITES:\n",
    "1. Hugin must be installed.\n",
    "   https://hugin.sourceforge.io/\n",
    "   - You must point the script to the 'bin' directory containing \"align_image_stack.exe\".\n",
    "   - Example Path: r\"C:\\Program Files\\Hugin\\bin\"\n",
    "2. Python Libraries:\n",
    "   - pip install rawpy imageio exifread\n",
    "\n",
    "IT USES THE HUGIN TOOLCHAIN:\n",
    "1. pto_gen:         Creates the project file.\n",
    "2. cpfind:          Finds matching control points in overlapping images (multi-row supported).\n",
    "3. autooptimiser:   Calculates geometry, warp, and photometric alignment.\n",
    "4. hugin_executor:  Renders the final high-resolution mosaic.\n",
    "\n",
    "SHOOTING & SETUP:\n",
    "- Optimized for ROTATIONAL stitching (standing in one spot, panning/tilting).\n",
    "- LINEAR SCANS: If you walked along an outcrop (linear translation), this script \n",
    "  may struggle with parallax. For linear scans, consider Microsoft ICE or Meshroom.\n",
    "- CLEAN DATA: The script groups images by timestamps. If you have rapid-burst \n",
    "  sequences (HDR brackets or sports mode) mixed in, the grouping logic will fail. \n",
    "  Please separate panorama sets into their own folder before processing.\n",
    "- SHOOTING PATTERN: Multi-row photomosaics are best collected by a Gigapan robot \n",
    "  for a uniform distribution. This script is made for those who wish to make handheld \n",
    "  \"Gigapan-like\" mosaics. \n",
    "  Best practice:\n",
    "  1. Ensure moderate overlap of images (30-40%).\n",
    "  2. Shoot in a snake pattern (Left->Right, Tilt Up, Right->Left).\n",
    "  3. Use a long focal length lens (preferably 85mm+ or 200mm) for flatter perspective.\n",
    "\n",
    "RUN MODES (Set in Configuration Section):\n",
    "1. Auto-Detect (Default):\n",
    "   - Uses TIME_THRESHOLD (e.g., 20.0 seconds) to detect when one mosaic ends \n",
    "     and the next begins.\n",
    "   - Requirement: You must pause for >20s between shooting different outcrops.\n",
    "2. Force Mode (FORCE_ALL_ONE_PANO = True):\n",
    "   - Treats the entire folder as a single giant mosaic.\n",
    "   - Use this for very large/long datasets where you might have paused during shooting.\n",
    "\n",
    "PERFORMANCE NOTE (The \"Go To Bed\" Rule):\n",
    "This process is computationally intensive. \n",
    "- Phase 1 (Matching) creates many \"tilted\" single images in the output folder. \n",
    "  DO NOT PANIC. These are temporary intermediate files.\n",
    "- Phase 2 (Rendering) compiles them into the final mosaic. \n",
    "- For large field seasons, it is recommended to run this script overnight.\n",
    "-------------------------------------------------------------------------------\n",
    "\"\"\""
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "6c02343e-4c66-49f3-ad55-0e7bf540127e",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "--- PANORAMA BATCH STITCHER STARTING ---\n",
      "Please select your INPUT folder from the popup window...\n",
      "No files found!\n"
     ]
    }
   ],
   "source": [
    "\"\"\"\n",
    "-------------------------------------------------------------------------------\n",
    "PANORAMA MULTI-ROW BATCH STITCHER\n",
    "-------------------------------------------------------------------------------\n",
    "Author:       Brian Willis\n",
    "Contact:      Willis77019@gmail.com\n",
    "License:      MIT License \n",
    "              (Use without restriction, but use at your own risk; no warranty of serviceability)\n",
    "\n",
    "DESCRIPTION:\n",
    "This script automates the stitching of multiple panoramic mosaics from a single\n",
    "folder of images. It uses Hugin tools to detect matching points (Multi-Row supported),\n",
    "optimize geometry, and render high-res outputs.\n",
    "\n",
    "PREREQUISITES:\n",
    "1. Hugin must be installed.\n",
    "2. Python Libraries: pip install rawpy imageio exifread\n",
    "\n",
    "SHOOTING TIPS:\n",
    "- Use a \"Snake\" pattern for multi-row (Left->Right, Up, Right->Left).\n",
    "- Overlap images by 30-40%.\n",
    "- Pause for >20s between different panoramas (if using Auto-Detect mode).\n",
    "-------------------------------------------------------------------------------\n",
    "\"\"\"\n",
    "\n",
    "import os\n",
    "import subprocess\n",
    "import glob\n",
    "import datetime\n",
    "import platform\n",
    "import sys\n",
    "import tkinter as tk\n",
    "from tkinter import filedialog\n",
    "\n",
    "# ================= USER CONFIGURATION =================\n",
    "\n",
    "# 1. HUGIN PATH DETECTION\n",
    "if platform.system() == \"Windows\":\n",
    "    HUGIN_EXEC_EXT = \".exe\"\n",
    "    HUGIN_BIN_PATH = r\"C:\\Program Files\\Hugin\\bin\" \n",
    "elif platform.system() == \"Darwin\": \n",
    "    HUGIN_EXEC_EXT = \"\"\n",
    "    HUGIN_BIN_PATH = \"/Applications/Hugin/HuginTools\"\n",
    "else: \n",
    "    HUGIN_EXEC_EXT = \"\"\n",
    "    HUGIN_BIN_PATH = \"/usr/bin\"\n",
    "\n",
    "# 2. RUN MODE\n",
    "# True:  Treats the ENTIRE folder as ONE giant mosaic.\n",
    "# False: Uses timestamps to detect separate panoramas automatically.\n",
    "FORCE_ALL_ONE_PANO = False\n",
    "\n",
    "# 3. TIME SETTINGS\n",
    "# If FORCE_ALL_ONE_PANO is False, gaps larger than this start a new pano.\n",
    "TIME_THRESHOLD = 20.0 \n",
    "\n",
    "# ======================================================\n",
    "\n",
    "def get_timestamp(file_path):\n",
    "    import exifread\n",
    "    try:\n",
    "        with open(file_path, 'rb') as f:\n",
    "            tags = exifread.process_file(f, stop_tag='EXIF DateTimeOriginal')\n",
    "            date_str = str(tags.get('EXIF DateTimeOriginal'))\n",
    "            return datetime.datetime.strptime(date_str, '%Y:%m:%d %H:%M:%S')\n",
    "    except:\n",
    "        return datetime.datetime.fromtimestamp(os.path.getmtime(file_path))\n",
    "\n",
    "def check_hugin_install():\n",
    "    test_tool = os.path.join(HUGIN_BIN_PATH, f\"pto_gen{HUGIN_EXEC_EXT}\")\n",
    "    if not os.path.exists(test_tool):\n",
    "        print(f\"ERROR: Hugin tool not found at: {test_tool}\")\n",
    "        return False\n",
    "    return True\n",
    "\n",
    "def stitch_panorama(group, output_folder, temp_folder):\n",
    "    # === IMPORTS ===\n",
    "    import rawpy\n",
    "    import imageio\n",
    "    import shutil\n",
    "    \n",
    "    # Setup filenames\n",
    "    base_name = os.path.splitext(os.path.basename(group[0]))[0]\n",
    "    pto_filename = f\"{base_name}.pto\"\n",
    "    output_prefix = f\"Pano_{base_name}\"\n",
    "    \n",
    "    print(f\"    -> Processing Pano: {base_name} ({len(group)} images)\")\n",
    "\n",
    "    # Tool Paths\n",
    "    pto_gen = os.path.join(HUGIN_BIN_PATH, f\"pto_gen{HUGIN_EXEC_EXT}\")\n",
    "    cpfind = os.path.join(HUGIN_BIN_PATH, f\"cpfind{HUGIN_EXEC_EXT}\")\n",
    "    autooptimiser = os.path.join(HUGIN_BIN_PATH, f\"autooptimiser{HUGIN_EXEC_EXT}\")\n",
    "    pano_modify = os.path.join(HUGIN_BIN_PATH, f\"pano_modify{HUGIN_EXEC_EXT}\") \n",
    "    executor = os.path.join(HUGIN_BIN_PATH, f\"hugin_executor{HUGIN_EXEC_EXT}\")\n",
    "\n",
    "    # Track temp files to delete later\n",
    "    temp_input_tifs = []\n",
    "\n",
    "    try:\n",
    "        # === STEP 0: CONVERT NEF TO TIF ===\n",
    "        current_inputs = []\n",
    "        for raw_file in group:\n",
    "            if raw_file.lower().endswith(('.nef', '.cr2', '.arw', '.dng')):\n",
    "                fname = os.path.basename(raw_file) + \".tif\"\n",
    "                tif_path = os.path.join(temp_folder, fname)\n",
    "                \n",
    "                # Only convert if it doesn't exist\n",
    "                if not os.path.exists(tif_path):\n",
    "                    try:\n",
    "                        with rawpy.imread(raw_file) as raw:\n",
    "                            rgb = raw.postprocess(use_camera_wb=True, no_auto_bright=True)\n",
    "                            imageio.imsave(tif_path, rgb)\n",
    "                    except Exception as e:\n",
    "                        print(f\"      [ERROR] Could not convert {os.path.basename(raw_file)}: {e}\")\n",
    "                        return\n",
    "                temp_input_tifs.append(tif_path)\n",
    "                current_inputs.append(os.path.basename(tif_path)) \n",
    "            else:\n",
    "                current_inputs.append(raw_file)\n",
    "\n",
    "        if not current_inputs:\n",
    "            print(\"      [ERROR] No valid images to process.\")\n",
    "            return\n",
    "\n",
    "        # === STEP 1: pto_gen ===\n",
    "        cmd_pto = [pto_gen, \"-o\", pto_filename] + current_inputs\n",
    "        subprocess.run(cmd_pto, cwd=temp_folder, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)\n",
    "\n",
    "        if not os.path.exists(os.path.join(temp_folder, pto_filename)):\n",
    "            print(f\"      [ERROR] Project creation failed.\")\n",
    "            return\n",
    "\n",
    "        # === STEP 2: cpfind ===\n",
    "        print(\"      -> Finding Control Points...\")\n",
    "        subprocess.run([cpfind, \"-o\", pto_filename, \"--multirow\", pto_filename], \n",
    "                       cwd=temp_folder, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)\n",
    "\n",
    "        # === STEP 3: autooptimiser ===\n",
    "        print(\"      -> Optimizing Geometry...\")\n",
    "        subprocess.run([autooptimiser, \"-a\", \"-m\", \"-s\", \"-o\", pto_filename, pto_filename], \n",
    "                       cwd=temp_folder, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)\n",
    "\n",
    "        # === STEP 3.5: SAFE CANVAS SHRINK (The \"Banana Saver\") ===\n",
    "        # --canvas=AUTO: Shrinks the canvas to fit the image data.\n",
    "        # We removed --crop=AUTO to preserve your curved edges.\n",
    "        subprocess.run([pano_modify, \"--canvas=AUTO\", \"-o\", pto_filename, pto_filename],\n",
    "                       cwd=temp_folder, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)\n",
    "\n",
    "        # === STEP 4: Render ===\n",
    "        print(\"      -> Rendering...\")\n",
    "        result = subprocess.run(\n",
    "            [executor, \"--stitching\", f\"--prefix={output_prefix}\", pto_filename],\n",
    "            cwd=temp_folder,\n",
    "            capture_output=True,\n",
    "            text=True\n",
    "        )\n",
    "\n",
    "        # === STEP 5: Move & Cleanup ===\n",
    "        generated_files = glob.glob(os.path.join(temp_folder, f\"{output_prefix}*\"))\n",
    "        moved_count = 0\n",
    "        \n",
    "        for f in generated_files:\n",
    "            if f.lower().endswith(('.tif', '.jpg', '.jpeg')):\n",
    "                dst = os.path.join(output_folder, os.path.basename(f))\n",
    "                if os.path.exists(dst): os.remove(dst)\n",
    "                shutil.move(f, dst)\n",
    "                moved_count += 1\n",
    "        \n",
    "        # Cleanup TIFs\n",
    "        for f in temp_input_tifs:\n",
    "            try:\n",
    "                if os.path.exists(f): os.remove(f)\n",
    "            except: pass\n",
    "\n",
    "        if moved_count > 0:\n",
    "            print(f\"      [DONE] Saved {moved_count} file(s).\")\n",
    "        else:\n",
    "            print(f\"      [WARNING] No output found. Log: {result.stderr[:200]}\")\n",
    "\n",
    "    except Exception as e:\n",
    "        print(f\"      [PYTHON ERROR] {e}\")\n",
    "        \n",
    "def main():\n",
    "    print(\"--- PANORAMA BATCH STITCHER STARTING ---\")\n",
    "    if not check_hugin_install(): return\n",
    "\n",
    "    root = tk.Tk()\n",
    "    root.withdraw()\n",
    "    print(\"Please select your INPUT folder from the popup window...\")\n",
    "    INPUT_FOLDER = filedialog.askdirectory(title=\"Select Input Folder Containing Photos\")\n",
    "    \n",
    "    if not INPUT_FOLDER: return\n",
    "\n",
    "    OUTPUT_FOLDER = os.path.join(INPUT_FOLDER, \"Stitched_Output\")\n",
    "    temp_folder = os.path.join(OUTPUT_FOLDER, \"temp_work\")\n",
    "    if not os.path.exists(OUTPUT_FOLDER): os.makedirs(OUTPUT_FOLDER)\n",
    "    if not os.path.exists(temp_folder): os.makedirs(temp_folder)\n",
    "\n",
    "    # Gather & Sort Files\n",
    "    extensions = ['*.JPG', '*.jpg', '*.TIF', '*.tif', '*.NEF', '*.nef']\n",
    "    files = []\n",
    "    for ext in extensions:\n",
    "        files.extend(glob.glob(os.path.join(INPUT_FOLDER, ext)))\n",
    "    \n",
    "    # Remove duplicates\n",
    "    unique_files = {}\n",
    "    for f in files:\n",
    "        unique_files[os.path.abspath(f).lower()] = f\n",
    "    files = sorted(list(unique_files.values()))\n",
    "\n",
    "    if not files:\n",
    "        print(\"No files found!\")\n",
    "        return\n",
    "\n",
    "    groups = []\n",
    "\n",
    "    # Grouping Logic\n",
    "    if FORCE_ALL_ONE_PANO:\n",
    "        print(f\"--- MODE: FORCING SINGLE PANORAMA ({len(files)} images) ---\")\n",
    "        groups.append(files) \n",
    "    else:\n",
    "        print(\"--- MODE: AUTO-DETECT via TIMESTAMP ---\")\n",
    "        files_with_time = [(f, get_timestamp(f)) for f in files]\n",
    "        files_with_time.sort(key=lambda x: x[1])\n",
    "\n",
    "        current_group = [files_with_time[0][0]]\n",
    "        for i in range(1, len(files_with_time)):\n",
    "            prev_time = files_with_time[i-1][1]\n",
    "            curr_file, curr_time = files_with_time[i]\n",
    "            \n",
    "            if (curr_time - prev_time).total_seconds() < TIME_THRESHOLD:\n",
    "                current_group.append(curr_file)\n",
    "            else:\n",
    "                if len(current_group) > 1: groups.append(current_group)\n",
    "                current_group = [curr_file]\n",
    "        if len(current_group) > 1: groups.append(current_group)\n",
    "\n",
    "    print(f\"Found {len(groups)} panoramas to stitch.\")\n",
    "    for i, group in enumerate(groups):\n",
    "        print(f\"Processing Pano {i+1}...\")\n",
    "        stitch_panorama(group, OUTPUT_FOLDER, temp_folder)\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "eff786bd-fe88-4c02-91b3-737876d151ec",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python [conda env:base] *",
   "language": "python",
   "name": "conda-base-py"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.13.9"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
