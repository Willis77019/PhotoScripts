{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "d0d0d050-9602-4dd5-82e4-472aacb8e592",
   "metadata": {},
   "source": [
    "# GeoPhoto-Tools: Gigapixel Panorama Video Generator\n",
    "Makes videos that pan along a photo.\n",
    "Author: Brian Willis<br>\n",
    "AI programming support: Gemini 3 pro<br>\n",
    "Contact: Willis77019@gmail.com<br>\n",
    "License:  MIT License (unrestricted: Use at your own risk)<br>\n",
    "\n",
    "Overview\n",
    "PhotoMosaicPan is a specialized Python utility designed for geologists and photographers who work with large panoramas (very large length to height ratio photos) and wish to convert these images into a video that pans along the photomosaic at a fixed speed. Such video displays are often better for sharing and presenting these types of images because the viewer can observe image details as the image moves through the field of view. The resulting video can be annotated before the video is made in and image editor (photoshop) to have annotations scroll with the image or can be annotated in a video editor for more control on annotation behavior.\n",
    "\n",
    "Standard video editors (DaVinci Resolve, Premiere) and standard Python libraries (PIL, OpenCV) often crash when attempting to load images that are 100,000+ pixels wide. This tool solves that problem using a Raw Binary Streaming engine.\n",
    "\n",
    "Key Features\n",
    "Zero-RAM Crash Proof: Uses FFmpeg to stream data directly to a raw binary file on the SSD, bypassing Python's memory limits.\n",
    "\n",
    "Batch Processing: Point it at a folder of 50 panoramas, and it will generate videos for all of them automatically.\n",
    "\n",
    "Polite Failure: If an image is corrupt, has high height/length ratio, or is too narrow for video rendering, it logs the error and skips to the next file without stopping the batch.\n",
    "\n",
    "High Speed: capable of processing ~10 gigapixel images into 4K video in minutes.\n",
    "\n",
    "Installation\n",
    "Install Python 3.10+\n",
    "\n",
    "Install Dependencies:\n",
    "Open your terminal or command prompt and run:\n",
    "\n",
    "Bash\n",
    "pip install imageio[ffmpeg] numpy opencv-python\n",
    "(Note: imageio[ffmpeg] automatically installs the FFmpeg binary, so you don't need to install it system-wide.)\n",
    "\n",
    "Usage\n",
    "1. Run the Script\n",
    "Double-click Pano_Panner_Batch_Raw.py or run it via terminal:\n",
    "\n",
    "Bash\n",
    "python Pano_Panner_Batch_Raw.py\n",
    "2. Select Mode\n",
    "[S] Single File: Select one specific panorama image.\n",
    "\n",
    "[B] Batch Folder: Select a folder. The script will find all valid images (.tif, .jpg, .png, etc.) inside.\n",
    "\n",
    "3. Processing\n",
    "The script will:\n",
    "\n",
    "Probe the image dimensions.\n",
    "\n",
    "Stream the pixel data to a temporary raw file on your C: drive (SSD recommended).\n",
    "\n",
    "Render a smooth 4K (3840x2160) panning video from left to right.\n",
    "\n",
    "Clean Up the temporary raw file immediately to free up disk space.\n",
    "\n",
    "The output video will be saved in the same folder as the source image, named Video_[OriginalName]_20s.mp4.\n",
    "\n",
    "Configuration\n",
    "You can open the script in any text editor to change the default settings at the top:\n",
    "\n",
    "Python\n",
    "# === CONFIGURATION ===\n",
    "VIDEO_WIDTH = 3840   # Output Width (Default: 4K)\n",
    "VIDEO_HEIGHT = 2160  # Output Height\n",
    "FPS = 30             # Frames Per Second\n",
    "DURATION = 20.0      # Duration of the pan in seconds\n",
    "Troubleshooting\n",
    "\"Could not detect dimensions\": This usually happens with corrupted headers or extremely irregular (non-rectangular) TIFF files. The script will skip these files.\n",
    "\n",
    "Disk Space: The script creates a temporary raw file that is roughly equal to the uncompressed size of the image (e.g., Width * Height * 3 bytes). Ensure your C: drive (or Temp drive) has at least 20-30GB of free space when processing very large files."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "17fb1d1d-5888-4192-ad37-a91503e33c1d",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "--- PANORAMA PANNER (BATCH RAW ENGINE) ---\n",
      "\n",
      "Select Mode:\n",
      "  [S] Single File\n",
      "  [B] Batch Folder\n"
     ]
    },
    {
     "name": "stdin",
     "output_type": "stream",
     "text": [
      "Choice (s/b):  s\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "--- STARTING BATCH (1 files) ---\n",
      "Temp file location: C:\\Users\\Willi\\AppData\\Local\\Temp\\pano_batch_temp.raw\n",
      "\n",
      "[File 1 of 1]\n",
      "\n",
      "Processing: Pano_DSC_0873.jpg...\n",
      "  [SKIP] Could not detect dimensions.\n",
      "\n",
      "--- BATCH COMPLETE ---\n",
      "Processed: 0/1\n",
      "Total Time: 0.0 minutes\n"
     ]
    }
   ],
   "source": [
    "\"\"\"\n",
    "-------------------------------------------------------------------------------\n",
    "PANORAMA PANNER (BATCH RAW ENGINE)\n",
    "-------------------------------------------------------------------------------\n",
    "Author:       Brian Willis\n",
    "Assisted by:  Gemini AI\n",
    "License:      MIT License \n",
    "\n",
    "DESCRIPTION:\n",
    "The Batch version of the \"Raw Binary\" engine.\n",
    "1. Converts each image to a raw binary stream on the C: drive.\n",
    "2. Memory-maps the stream to render the video.\n",
    "3. Automatically cleans up the temp file before starting the next image.\n",
    "\n",
    "PREREQUISITES:\n",
    "- pip install imageio[ffmpeg] numpy opencv-python\n",
    "-------------------------------------------------------------------------------\n",
    "\"\"\"\n",
    "\n",
    "import os\n",
    "import sys\n",
    "import subprocess\n",
    "import re\n",
    "import time\n",
    "import glob\n",
    "import tkinter as tk\n",
    "from tkinter import filedialog\n",
    "\n",
    "# === LIBRARIES ===\n",
    "try:\n",
    "    import imageio_ffmpeg\n",
    "    import numpy as np\n",
    "    import cv2\n",
    "except ImportError:\n",
    "    print(\"Missing libraries! Please run:\")\n",
    "    print(\"pip install imageio[ffmpeg] numpy opencv-python\")\n",
    "    sys.exit()\n",
    "\n",
    "# === CONFIGURATION ===\n",
    "VIDEO_WIDTH = 3840   # 4K UHD\n",
    "VIDEO_HEIGHT = 2160\n",
    "FPS = 30\n",
    "DURATION = 20.0      # Duration per video in seconds\n",
    "\n",
    "# ==============================\n",
    "\n",
    "def get_image_dims(ffmpeg_exe, file_path):\n",
    "    \"\"\"Probes image dimensions using FFmpeg (Zero RAM).\"\"\"\n",
    "    try:\n",
    "        cmd = [ffmpeg_exe, \"-i\", file_path]\n",
    "        process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True)\n",
    "        _, stderr = process.communicate()\n",
    "        \n",
    "        # Regex for \"Video: ..., 1234x5678, ...\"\n",
    "        match = re.search(r\", (\\d+)x(\\d+)\", stderr)\n",
    "        if not match:\n",
    "            # Fallback regex\n",
    "            match = re.search(r\"Video:.* (\\d{3,})x(\\d{3,})\", stderr)\n",
    "            \n",
    "        if match:\n",
    "            return int(match.group(1)), int(match.group(2))\n",
    "    except:\n",
    "        pass\n",
    "    return None, None\n",
    "\n",
    "def process_single_file(ffmpeg_exe, src_path, temp_raw_path):\n",
    "    \"\"\"\n",
    "    Main logic to process one image. Returns True on success.\n",
    "    \"\"\"\n",
    "    filename = os.path.basename(src_path)\n",
    "    folder = os.path.dirname(src_path)\n",
    "    name = os.path.splitext(filename)[0]\n",
    "    output_video = os.path.join(folder, f\"Video_{name}_{int(DURATION)}s.mp4\")\n",
    "\n",
    "    print(f\"\\nProcessing: {filename}...\")\n",
    "\n",
    "    try:\n",
    "        # 1. Probe Dimensions\n",
    "        w, h = get_image_dims(ffmpeg_exe, src_path)\n",
    "        if w is None:\n",
    "            print(\"  [SKIP] Could not detect dimensions.\")\n",
    "            return False\n",
    "        \n",
    "        print(f\"  Dims: {w} x {h}\")\n",
    "\n",
    "        # 2. Convert to Raw (Save to SSD)\n",
    "        # Note: We overwrite the same temp file every time to save space\n",
    "        if os.path.exists(temp_raw_path):\n",
    "            try: os.remove(temp_raw_path)\n",
    "            except: pass\n",
    "\n",
    "        print(f\"  Streaming to raw temp file (SSD)...\")\n",
    "        cmd_convert = [\n",
    "            ffmpeg_exe, \"-y\",\n",
    "            \"-i\", src_path,\n",
    "            \"-f\", \"rawvideo\",\n",
    "            \"-pix_fmt\", \"rgb24\",\n",
    "            temp_raw_path\n",
    "        ]\n",
    "        subprocess.run(cmd_convert, check=True, stderr=subprocess.DEVNULL)\n",
    "\n",
    "        # 3. Memory Map & Render\n",
    "        raw_map = np.memmap(temp_raw_path, dtype='uint8', mode='r', shape=(h, w, 3))\n",
    "        \n",
    "        # Geometry\n",
    "        crop_h = h\n",
    "        target_aspect = VIDEO_WIDTH / VIDEO_HEIGHT\n",
    "        crop_w = int(crop_h * target_aspect)\n",
    "        \n",
    "        if crop_w > w:\n",
    "            print(f\"  [SKIP] Image too narrow (Needs {crop_w}px, has {w}px).\")\n",
    "            del raw_map\n",
    "            return False\n",
    "\n",
    "        # Video Writer\n",
    "        fourcc = cv2.VideoWriter_fourcc(*'mp4v') \n",
    "        video = cv2.VideoWriter(output_video, fourcc, FPS, (VIDEO_WIDTH, VIDEO_HEIGHT))\n",
    "        \n",
    "        total_frames = int(DURATION * FPS)\n",
    "        max_pan_x = w - crop_w\n",
    "        step_per_frame = max_pan_x / total_frames\n",
    "        \n",
    "        start_time = time.time()\n",
    "        \n",
    "        # Render Loop\n",
    "        for i in range(total_frames):\n",
    "            curr_x = int(i * step_per_frame)\n",
    "            \n",
    "            # Read from SSD (Virtual RAM)\n",
    "            frame_raw = raw_map[0:crop_h, curr_x:curr_x+crop_w]\n",
    "            \n",
    "            # Resize\n",
    "            frame_final = cv2.resize(frame_raw, (VIDEO_WIDTH, VIDEO_HEIGHT), interpolation=cv2.INTER_LINEAR)\n",
    "            \n",
    "            # RGB -> BGR\n",
    "            frame_bgr = cv2.cvtColor(frame_final, cv2.COLOR_RGB2BGR)\n",
    "            video.write(frame_bgr)\n",
    "            \n",
    "            if i % 30 == 0 or i == total_frames - 1:\n",
    "                percent = ((i + 1) / total_frames) * 100\n",
    "                print(f\"\\r  Rendered {percent:.1f}% ({i+1}/{total_frames})\", end='')\n",
    "\n",
    "        video.release()\n",
    "        del raw_map # Close file lock\n",
    "        print(f\"\\n  [DONE] Saved video.\")\n",
    "        return True\n",
    "\n",
    "    except Exception as e:\n",
    "        print(f\"\\n  [ERROR] Failed: {e}\")\n",
    "        return False\n",
    "    finally:\n",
    "        # Always try to clean up temp file immediately to free space for next file\n",
    "        if os.path.exists(temp_raw_path):\n",
    "            try: os.remove(temp_raw_path)\n",
    "            except: pass\n",
    "\n",
    "def main():\n",
    "    print(\"--- PANORAMA PANNER (BATCH RAW ENGINE) ---\")\n",
    "    \n",
    "    ffmpeg_exe = imageio_ffmpeg.get_ffmpeg_exe()\n",
    "    \n",
    "    # 1. Setup Temp File on C: Drive (SSD)\n",
    "    # We use a single fixed temp filename that gets reused\n",
    "    temp_dir = os.environ.get('TEMP', os.path.expanduser('~'))\n",
    "    temp_raw_path = os.path.join(temp_dir, \"pano_batch_temp.raw\")\n",
    "    \n",
    "    # 2. Select Mode\n",
    "    print(\"\\nSelect Mode:\")\n",
    "    print(\"  [S] Single File\")\n",
    "    print(\"  [B] Batch Folder\")\n",
    "    mode = input(\"Choice (s/b): \").strip().lower()\n",
    "    \n",
    "    files = []\n",
    "    root = tk.Tk()\n",
    "    root.withdraw()\n",
    "\n",
    "    if mode == 'b':\n",
    "        folder = filedialog.askdirectory(title=\"Select Input Folder\")\n",
    "        if not folder: return\n",
    "        for ext in ['*.tif', '*.tiff', '*.jpg', '*.png', '*.bmp', '*.psd']:\n",
    "            files.extend(glob.glob(os.path.join(folder, ext)))\n",
    "            files.extend(glob.glob(os.path.join(folder, ext.upper())))\n",
    "        files = sorted(list(set(files)))\n",
    "    else:\n",
    "        f = filedialog.askopenfilename(title=\"Select Image\")\n",
    "        if f: files = [f]\n",
    "\n",
    "    if not files: return\n",
    "\n",
    "    # 3. Batch Loop\n",
    "    print(f\"\\n--- STARTING BATCH ({len(files)} files) ---\")\n",
    "    print(f\"Temp file location: {temp_raw_path}\")\n",
    "    \n",
    "    success_count = 0\n",
    "    start_batch = time.time()\n",
    "    \n",
    "    for i, f in enumerate(files):\n",
    "        print(f\"\\n[File {i+1} of {len(files)}]\")\n",
    "        if process_single_file(ffmpeg_exe, f, temp_raw_path):\n",
    "            success_count += 1\n",
    "            \n",
    "    # Final Summary\n",
    "    elapsed = (time.time() - start_batch) / 60\n",
    "    print(f\"\\n--- BATCH COMPLETE ---\")\n",
    "    print(f\"Processed: {success_count}/{len(files)}\")\n",
    "    print(f\"Total Time: {elapsed:.1f} minutes\")\n",
    "    \n",
    "    # Final Cleanup check\n",
    "    if os.path.exists(temp_raw_path):\n",
    "        try: os.remove(temp_raw_path)\n",
    "        except: pass\n",
    "        \n",
    "    input(\"Press Enter to exit...\")\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "5da30026-697a-48d0-8312-c7b524be8e8e",
   "metadata": {},
   "outputs": [],
   "source": [
    "exit\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python [conda env:base] *",
   "language": "python",
   "name": "conda-base-py"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.13.9"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
